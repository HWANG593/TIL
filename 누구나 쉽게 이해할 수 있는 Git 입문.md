# 누구나 쉽게 이해할 수 있는 Git 입문

## 입문편

<br>

#### push

* 웹 상의 원격 저장소로 변경된 파일을 업로드하는 것
* push를 실행하면, 원격 저장소에 내 변경 이력이 업로드되어, 원격 저장소와 로컬 저장소가 동일한 상태가 된다.

<br>

#### clone

* 원격 저장소 복제
* 변경 이력도 함께 로컬 저장소에 복제되어 온다.
* 원래 원격 저장소와 같이 이력을 참조하고 커밋을 진행할 수 있다.

<br>

#### pull

* 원격 저장소에서 로컬 저장소로 업데이트하려면 풀(pull)을 실행한다.
* pull을 실행하면 원격 저장소에서 최신 변경 이력을 다운로드하여 내 로컬 저장소에 그 내용을 적용한다.

<br>

#### merge

* 내가 끌어온 저장소가 최신 버전이 아닌 경우, 즉 내가 pull을 실행한 후 다른 사람이 push를 하여 원격 저장소를 업데이트 해버린 경우에는 나의 push 요청이 거부된다.
* 이런 경우 병합(merge) 작업을 진행하여 다른 사람의 업데이트 이력을 내 저장소에도 갱신해야 한다.
* 병합하지 않은 채로 이력을 덮어쓰게 되면 다른 사람이 push한 업데이트 내역(커밋)이 사라져 버린기 때문이다.



#### merge 충돌 해결

* 병합 기능은 Git에서 변경한 부분을 자동을 통합해주는 기능이다
* 그러나 경우에 따라 자동으로 병합할 수 없는 경우도 있다.
* 충돌이 발생하면 두 변경 내용 중 어느 쪽을 저장할 것인지 자동으로 판단할 수 없다.
* 이 부분을 직접 수정해주어야 한다.
* ```=====```로 구분된 윗 부분이 로컬 저장소, 아랫 부분이 원격 저장소의 변경 내용

<br>

## 발전편

### Branch

* 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능
* 각자 독립적인 작업 영역(저장소)에서 마음대로 소스코드를 변경할 수 있다.
* 분리된 작업 영역에서 변경된 내용은 하나의 새로운 버전으로 만들어 낼 수 있다.

<br>

#### branch

* 독립적으로 어떤 작업을 진행하기 위한 개념

* 브랜치는 다른 브랜치와 병합(Merge)함으로써, 작업한 내용을 다시 새로운 하나의 브랜치로 모을 수 있다.

<br>

#### master branch

* 저장소에 새로운 파일을 추가하거나, 추가한 파일의 내용을 변경하여 저장(Commit)하는 것은 master 브랜치를 통해 처리할 수 있다.
* 'master'가 아닌 새로운 브랜치를 선언(checkout)하지 않는다면 모든 작업은 master 브랜치에서 이루어진다.

<br>

### 브랜치 만들기

#### 통합 브랜치

* 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치
* 안정적인 상태를 유지하는 것이 중요하다
* 즉, 현재 작업 중인 소스코드가 모든 기능이 정상적으로 동작하는 상태
* 일반적으로 'master' 브랜치를 통합 브랜치로 사용한다

<br>

#### 토픽 브랜치

* 기능 추가나 버그 수정과 같은 단위 작업을 위한 브랜치
* 여러 작업을 동시에 진행할 때에는 그 수 만큼 브랜치를 생성할 수 있다.
* 토픽 브랜치에서 특정 작업이 완료되면 통합 브랜치에 병합(merge)하는 방식으로 진행

<br>

### 브랜치 전환하기

* Git에서는 항상 작업할 브랜치를 미리 선택해야 한다.
* 다른 브랜치에서 작업하고 싶을 때는 ```checkout```명령어를 시행한다.'
* ```checkout```실행 시 브랜치 안에 있는 마지막 커밋 내용이 작업 트리(폴더)에 펼쳐진다.
* 브랜치가 전환되면 이 이후에 실행한 커밋은 전환한 브랜치에 추가된다.

<br>

#### stash

* 커밋하지 않은 변경 내용이나 새롭게 추가한 파일이 인덱스와 작업 트리에 남아 있는 채로 다른 브랜치로 전환(checkout)하면, 그 변경 내용은 기존 브랜치가 아닌 전환된 브랜치에서 커밋할 수 있다.
* 단, 커밋 가능한 변경 내용 중에 전환된 브랜치에서도 한 차례 변경이 되어 있는 경우에는 체크 아웃에 실패할 수 있다. 
* 이 경우 이전 브랜치에서 커밋하지 않은 변경 내용을 커밋하거나, stash를 이용해 일시적으로 변경 내용을 다른 곳에 저장하여 충돌을 피하게 한 뒤 체크아웃을 해야한다.
* stash란 파일의 변경 내용을 일시적으로 기록해두는 영역이다.
* stash를 사용하여 작업트리와 인덱스 내에서 아직 커밋하지 않은 변경을 일시적으로 저장해 둘 수 있다.
* 이 stash에 저장된 변경 내용은 나중에 다시 불러와 원래의 브랜치나 다른 브랜치에 커밋할 수 있다.

<br>

### 브랜치 통합하기

* 작업이 완료된 토픽 브랜치는 최종적으로 통합 브랜치에 병합된다.
* 브랜치 통합에는 merge와 rebase를 사용하는 방법 2가지가 있다.

<br>

#### merge

> master 브랜치에서 분기하는 bugfix라는 브랜치가 있다고 가정

<br>

* fast-forword 병합
  * master 브랜치의 상태가 이전부터 변경되지 않았다면, 'bugfix' 브랜치의 이력은 'master' 브랜치의 이력을 모두 포함하고 있다
  * 따라서, 'master' 브랜치는 단순히 이동하기만 해도 'bugfix' 브랜치의 내용을 적용할 수 있다.

<br>

* non fast-forward 병합
  * 'bugfix' 브랜치를 분기한 후에 'master' 브랜치에 여러가지 변경 사항이 적용되는 경우
  * 이 경우 'master' 브랜치 내의 변경 내용과 'bugfix' 브랜치 내의 변경 내용을 하나로 통합할 필요가 있다.
  * 따라서, 양쪽의 변경을 가져온 'merge commit'을 실행하게 된다.
  * non fast-forward 병합을 실행하면 브랜치가 그대로 남기 때문에 그 브랜치로 실행한 작업 확인 및 브랜치 관리 면에서 더 유용할 수있다.



#### rebase

> master 브랜치에서 분기하는 bugfix라는 브랜치가 있다고 가정

* non fast-forward 병합
  * 'bugfix' 브랜치를 'master' 브랜치에 rebase하면 'bugfix' 브랜치의 이력이 'master' 브랜치의 뒤로 이동하게 된다.
  * 따라서 이력이 하나의 줄기로 이어지게 된다.
  * 이때 'bugfix'의 이동하는 커밋내에 포함되는 내용이 'master'의 커밋된 버전들과 충돌하는 부분이 생길 수 있다. 
  * 그 때는 각각의 커밋에서 발생한 충돌 내용을 수정할 필요가 있다.

<br>

* fast-forward 병합
  * 'master' 브랜치의 위치를 변경하기 위함



#### merge와 rebase 차이

* merge
  * 변경 내용의 이력이 모두 그대로 남아 있기 때문에 이력이 복잡해짐

<br>

* rebase
  * 이력은 단순해지지만, 원래의 커밋 이력이 변경됨
  * 정확한 이력을 남겨야할 필요가 있을 경우에는 사용하면 안된다.

